"""
Эта задачка про lambda функцию в list comprehension.
Мне на собесе был поставлен вопрос, что получиться, если взять, например, второй элемент списка из
"мистического выражения" ниже (это будет lambda функция) и вызвать ее, передав число 5...Я про себя подумал:
"а как часто вы там у себя в проекте такую херню пишете? Если часто, то, наверное, я пас над ним работать.".
Но ответил я, что будет 7. Наивно полагая, что 'y' на третьей итерации будет равен 2 и, прибавив к нему 5, мы получим 7.

Но хуй на руль... Давайте разбираться.
"""

# Мистическое выражение, созданное задрочить твой мозг, которое ни один разраб в здравом уме не напишет
mystic_lst = [lambda x: x+y for y in range(100)]
print(mystic_lst[2](5))


# А вот теперь мы его разложим и проиллюстрируем, что в нем, да как.
# В нормальном проекте я бы такой хуйней не занимался.
# Напиши import this и поймешь почему не нужно по чем зря ебать голову ни себе, ни людям.

# Итак...

# У нас там list comprehension, его суть в том, что мы формируем список.
# А здесь мы создаем пустой список, в который накинем элементов по аналогии с LC, но визуально будет понятнее.
rslt_lst = []
# Итерируемся от 0 до 99 и на каждой итерации 'y' принимает разное значения.
for y in range(100):
    # Определяем функцию (аналог нашей лямбды). Эта функция запоминает крайнее значение 'y', которое было.
    def x_plus_y(x):
        return x + y
    # Одна и та же функция попадает в список, просто несколько раз(по кол-ву итераций).
    # Но эта функция отлавливает крайнее состояние 'y' и будет работать именно с ним.
    # Эта хуйня замыканиями называется, если я не ошибаюсь.
    rslt_lst.append(x_plus_y)
# И вот на выходе имеем список с одной и той же функцией.
# Эта функция отловила состояние 'y' и с ним работает. И ей пофиг на какой итерации она была добавлена в список.
# Она одна и та же, и 'y' для нее существует только с крайним значением - 99.
# Поэтому пофиг какую функцию из списка мы возьмем, суммировать переданное число она будет с 'y' == 99.
print(rslt_lst[0](5))

# Ради интереса, посмотрим какое имя у вызываемой функции из разных элементов списка.
# 0, 1 или 37 - пофиг, это все одна и та же функция x_plus_y
print(rslt_lst[0].__name__)
print(rslt_lst[1].__name__)
print(rslt_lst[37].__name__)
